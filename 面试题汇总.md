
# MySQL

## 1、如何保证`MySQL`和`Redis`的数据一致性？

答：`Redis`是用来实现应用和数据库之间的缓存层，目的是为了减少数据库的IO，还可以提升数据的IO性能。当应用层需要读取数据库中某个数据的时候，首先会先尝试从`Redis`中获取，如果命中则直接返回，如果没命中再去数据库中获取，然后将查询到的数据缓存在`Redis`中。这样会出现一个问题，一份数据同时保存在数据库和`Redis`里面，当数据发生变化时，需要同时去更新数据库和`Redis`，由于更新操作是有先后顺序的，并且它并不想MySQL事务中的的多表操作可以满足ACID特性，所以就会出现数据一致性的问题。在这种情况下，可以有几种选择。

第一种，先更新数据库，再更新`Redis`。如果缓存更新失败，就会导致数据不一致。

第二种，先删除`Redis`，在更新数据库。理想情况下，是应用下次访问`Redis`的时候发现没有命中，再去数据库里面查询数据并将最新的数据缓存在`Redis`中。但是在极端情况下，由于删除`Redis`和和更新数据库并不是原子操作，所以在这个过程中如果有别的线程来访问，还是会存在数据不一致的情况。

所以如果需要在极端情况下仍然保证数据一致性问题，就只能采用最终一致性的解决方案，比如，基于`RocketMQ`的可靠性消息通信。还可以直接通过`canal`组件监控`MySQL`的`Binlog`日志，把更新后的数据缓存到`Redis`中。

[详细查看](https://github.com/ProgrammerGoGo/document/blob/main/MySQL/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81MySQL%E5%92%8CRedis%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F.md)

## `MySQL`如何解决幻读？

答：在RR也就是可重复读的隔离级别下，InnoDB使用`MVCC`机制来解决幻读问题，`MVCC`就是是使用了乐观锁的机制，他是针对不同事务生成不同快照版本，然后通过`Undo Log`版本链来进行管理，并且规定了高版本能看到低版本的事务变更，低版本看不到高版本的事务变更，从而实现了不同事务之间的数据隔离，解决了幻读的问题。但是当事务里面存在当前读的情况，那么它是直接读取了内存中的当前数据，跳过了快照读，所以还是会存在幻读的问题。可以通过两种方式来解决，第一种是避免当前读的情况。第二种是可以引入LBCC的方式解决。

[详细查看](https://github.com/ProgrammerGoGo/document/blob/main/MySQL/%60MySQL%60%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%EF%BC%9F.md)
