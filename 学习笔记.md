

高性能

高可靠 为了减少故障发生的次数

高可用 减少故障发生后的恢复时间。MySQL的MHA、Redis sentinel、HDFS

数据一致性
* 分布式事务一致性
* 高可用的多副本一致性

高可用架构的五个核心问题：
1. 如何实现故障的探测
2. 如何解决脑裂问题
3. 如何做到数据的一致性
4. 如何做到对客户端透明
5. 如何解决高可用依赖的连环套问题



限流
分布式解决方案
* 2PC - 理论、实现、问题（只适用于一个微服务下直连两个数据，基于数据库XA协议，对于多个微服务之间的分布式事务问题无法解决）
* 最终一致性解决方案 - 1、消息数据表 2、基于事务消息（阿里 rocketmq）
* TCC - 支付宝，可以理解为应用层面的2PC，
* 事务状态表+事务补偿
* 同步双写+异步对账 - 从“结果”的角度检查“过程”。
* 弱一致+基于状态的时候补偿 - 妥协方案
* seata框架 - 阿里云，包括 TA、TCC、XA模式，本质上都是基于2PC，主要解决了2PC只能针对单机直连两个数据的场景的限制，通过独立部署的Server（TC）控制多个微服务间的分布式事务。


长事务的问题？MySQL45讲，MVCC






# 二叉树

特性：
* 在二叉树中，第 i 层上至多有2^(i−1) 个节点（i≥1）
* 深度为k的二叉树至多有2^k−1个节点（k≥1）
* 对一棵二叉树，如果叶子节点的个数为n0，度为2的节点个数为n2，则n0=n2+1
* 具有n个节点的完全二叉树的深度为⌊log2n⌋+1 或 ⌊log2（n+1）⌋

> 性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2 * n2+1。两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。

二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：

![image](https://github.com/ProgrammerGoGo/document/assets/98639494/5319f0c2-1b27-4465-ab7e-295d183533a8)


# 等比数列 对数函数（log）
如果a^x =N（a>0，且a≠1），那么数x叫做以a为底N的对数，记作x=logaN，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。














