

# 案例一

> 间隙锁导致的死锁

**表结构：**

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```

![image](https://github.com/ProgrammerGoGo/document/assets/98639494/935b397b-124e-4b21-8bb8-6a60273259e4)

其实都不需要用到后面的update语句，就已经形成死锁了。我们按语句执行顺序来分析一下：

* session A 执行select ... for update语句，由于id=9这一行并不存在，因此会加上间隙锁(5,10);

* session B 执行select ... for update语句，同样会加上间隙锁(5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；

* session B 试图插入一行(9,9,9)，被session A的间隙锁挡住了，只好进入等待；

* session A试图插入一行(9,9,9)，被session B的间隙锁挡住了。

至此，两个session进入互相等待状态，形成死锁。当然，InnoDB的死锁检测马上就发现了这对死锁关系，让session A的insert语句报错返回了。



